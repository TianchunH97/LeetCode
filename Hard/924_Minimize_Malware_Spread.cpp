// LeetCode 924: Minimize Malware Spread

#include <vector>
#include <unordered_map>

using namespace std;

class Solution {
    vector<int> pre;
    int find(int root) {
        if (root == pre[root]) return root;
        int son = root;
        int tmp;
        while (root != pre[root]) {
            root = pre[root];
        }
        while (son != root) {
            tmp = pre[son];
            pre[son] = root;
            son = tmp;
        }
        return root;
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        pre.resize(n);
        for (int i = 0; i < n; i++) {
            pre[i] = i;
        }
        for (int i = 0; i < n-1; i++) {
            for (int j = i+1; j < n; j++) {
                if (graph[i][j] == 1) pre[find(i)] = find(j);
            }
        }
        unordered_map<int, int> nodecount;
        for (int i = 0; i < n; i++) {
            if (nodecount.count(find(i))) nodecount[pre[i]] += 1;
            else nodecount[pre[i]] = 1;
        }
        unordered_map<int, vector<int>> map;
        int min_init = INT_MAX;
        for (int i = 0; i < initial.size(); i++) {
            map[pre[initial[i]]].push_back(initial[i]);
            min_init = min(min_init, initial[i]);
        }
        int ret = min_init;
        int maxsize = 0;
        for (auto it = map.begin(); it != map.end(); it++) {
            if (it->second.size() == 1) {
                if (nodecount[it->first] > maxsize) {
                    maxsize = nodecount[it->first];
                    ret = it->second[0];
                }
                else if (nodecount[it->first] == maxsize) {
                    ret = min(ret, it->second[0]);
                }
                else continue;
            }
        }
        return ret;
    }
};